/*
* DO NOT MODIFY THIS COMMENT
* Generated by devmate
* Test model: 6e03d9e7-f743-4d02-8c64-f1089cacc5b6
*/
package util.alltogether;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.BiConsumer;
import java.util.function.Function;
import java.util.stream.Stream;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.joda.time.DateTime;

@SuppressWarnings("unused")
public class AllTogetherTest {
	
//region Custom Assertions
	private static void assertIsCreditApproved(AllTogether instance, CreditReturnStatus result, CustomMatcherIsCreditApprovedTestData data) {
	    // TODO implement Custom Assertion
	    // please implement your own custom assertion here
	    // you can find the parameters defined for your custom matcher under data.<name>CustomMatcher
	    // assertEqual(data.<name>CustomMatcher, result);
		assertEquals(data.isApprovedCustomMatcher, result.approved);
	}
//endregionâˆ«

//region Scenarios
	//A new scenario
	@ParameterizedTest(name = "{1} [{index}] {2}")
	@MethodSource({"Scenario1Source"})
	public void Scenario1Test(Scenario1TestData data, String TestName, String TestDescription) {
		ActualResultStorage.setStorage(); //saves the results of the called Methods
		
		assertion(data, data.S1M1.methodName, data.C1, data.S1M1.expectedResult, data.S1M1.call());
	}
//endregion

//region Data

//=========================================================================================================================
//Please modify this section only in the Modeleditor not here in the code, because otherwise it will cause merge conflicts!
//=========================================================================================================================
	//A new scenario
	private static Stream<Arguments> Scenario1Source() throws Exception {
		return Stream.of(
			Arguments.of(
				new Scenario1TestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(1990, 3, 4, 0, 0), "US", "John Brook"),
					/* S1M1 = */ new S1M1Parameters<>(
						/* Integer creditSought = */ 100,
						/* Integer duration = */ 12,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.CUSTOM_ASSERTION,
							/* customAction = */ (i, r) -> assertIsCreditApproved(i, r, 
								new CustomMatcherIsCreditApprovedTestData(
									/* isApprovedCustomMatcher = */ true
								)
							)
						)
					)
				),
				/* testCaseName = */ "p1",
				/* testCaseDescription = */ ""
			),
			Arguments.of(
				new Scenario1TestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(1990, 3, 4, 0, 0), "US", "John Brook"),
					/* S1M1 = */ new S1M1Parameters<>(
						/* Integer creditSought = */ 2000,
						/* Integer duration = */ 12,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.CUSTOM_ASSERTION,
							/* customAction = */ (i, r) -> assertIsCreditApproved(i, r, 
								new CustomMatcherIsCreditApprovedTestData(
									/* isApprovedCustomMatcher = */ false
								)
							)
						)
					)
				),
				/* testCaseName = */ "n1",
				/* testCaseDescription = */ "M1:duration: Invalid 18 - 25"
			),
			Arguments.of(
				new Scenario1TestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(1990, 3, 4, 0, 0), "US", "John Brook"),
					/* S1M1 = */ new S1M1Parameters<>(
						/* Integer creditSought = */ 2000,
						/* Integer duration = */ 50,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.CUSTOM_ASSERTION,
							/* customAction = */ (i, r) -> assertIsCreditApproved(i, r, 
								new CustomMatcherIsCreditApprovedTestData(
									/* isApprovedCustomMatcher = */ false
								)
							)
						)
					)
				),
				/* testCaseName = */ "n2",
				/* testCaseDescription = */ "M1:duration: Invalid 25+"
			),
			Arguments.of(
				new Scenario1TestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(1990, 3, 4, 0, 0), "US", "John Brook"),
					/* S1M1 = */ new S1M1Parameters<>(
						/* Integer creditSought = */ 2000,
						/* Integer duration = */ 12,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.CUSTOM_ASSERTION,
							/* customAction = */ (i, r) -> assertIsCreditApproved(i, r, 
								new CustomMatcherIsCreditApprovedTestData(
									/* isApprovedCustomMatcher = */ false
								)
							)
						)
					)
				),
				/* testCaseName = */ "n3",
				/* testCaseDescription = */ "M1:creditSought: Credit 18 - 25"
			),
			Arguments.of(
				new Scenario1TestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(1990, 3, 4, 0, 0), "US", "John Brook"),
					/* S1M1 = */ new S1M1Parameters<>(
						/* Integer creditSought = */ 20000,
						/* Integer duration = */ 12,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.CUSTOM_ASSERTION,
							/* customAction = */ (i, r) -> assertIsCreditApproved(i, r, 
								new CustomMatcherIsCreditApprovedTestData(
									/* isApprovedCustomMatcher = */ false
								)
							)
						)
					)
				),
				/* testCaseName = */ "n4",
				/* testCaseDescription = */ "M1:creditSought: Credit Over 25"
			),
			Arguments.of(
				new Scenario1TestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(2010, 1, 1, 0, 0), "US", "John Brook"),
					/* S1M1 = */ new S1M1Parameters<>(
						/* Integer creditSought = */ 100,
						/* Integer duration = */ 12,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.EXCEPTION,
							/* expectedException = */ Exception.class
						)
					)
				),
				/* testCaseName = */ "n5",
				/* testCaseDescription = */ "C1: Too Young"
			),
			Arguments.of(
				new Scenario1TestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(2100, 1, 2, 0, 0), "US", "John Brook"),
					/* S1M1 = */ new S1M1Parameters<>(
						/* Integer creditSought = */ 100,
						/* Integer duration = */ 12,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.EXCEPTION,
							/* expectedException = */ Exception.class
						)
					)
				),
				/* testCaseName = */ "n6",
				/* testCaseDescription = */ "C1: DOB in future"
			),
			Arguments.of(
				new Scenario1TestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(1990, 3, 4, 0, 0), "DE", "John Brook"),
					/* S1M1 = */ new S1M1Parameters<>(
						/* Integer creditSought = */ 100,
						/* Integer duration = */ 12,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.EXCEPTION,
							/* expectedException = */ Exception.class
						)
					)
				),
				/* testCaseName = */ "n7",
				/* testCaseDescription = */ "C1: Not US"
			)
		);
	}
//endregion

//region Types

//=========================================================================================================================
//Please modify this section only in the Modeleditor not here in the code, because otherwise it will cause merge conflicts!
//=========================================================================================================================
	static class Scenario1TestData {
	    public final AllTogether C1;
	    public final S1M1Parameters<Scenario1TestData> S1M1;
	    
	    public Scenario1TestData(AllTogether C1, S1M1Parameters<Scenario1TestData> S1M1) {
	    	this.C1 = C1;
	    	this.S1M1 = S1M1;
	    }
	}

	static class S1M1Parameters<TestData> {
		public final String methodName = "S1M1";
	    public final ObjectWrapper<Integer> creditSought;
	    public final ObjectWrapper<Integer> duration;
	    public final Result<TestData, AllTogether, CreditReturnStatus> expectedResult;
		public S1M1Parameters(Integer creditSought, Integer duration, String[] referencingMethodName, Result<TestData, AllTogether, CreditReturnStatus> expectedResult) {
			this.creditSought = new ObjectWrapper<>(creditSought, referencingMethodName[0]);
			this.duration = new ObjectWrapper<>(duration, referencingMethodName[1]);
	   		this.expectedResult = expectedResult;
	    }
	    
	    public ExceptionFunction<AllTogether, CreditReturnStatus> call() {
	    	return i ->
	    	 i.checkCredit(creditSought.get(), duration.get());
		}
	}

	static class CustomMatcherIsCreditApprovedTestData {
	    public final Boolean isApprovedCustomMatcher;
	    
	    public CustomMatcherIsCreditApprovedTestData(Boolean isApproved) {
	    	this.isApprovedCustomMatcher = isApproved;
	    }
	}
//endregion

//region Utility Classes

//=========================================================================================================================
//Please modify this section only in the Modeleditor not here in the code, because otherwise it will cause merge conflicts!
//=========================================================================================================================
	public static class ObjectWrapper<T> {
		public T object;
		public String referencingMethodName;
		
		public ObjectWrapper(T object, String referencingMethodName) {
			this.object = object;
			this.referencingMethodName = referencingMethodName;
		}
		
		public T get() {
			return ActualResultStorage.getOrDefault(referencingMethodName, object);
		}
	}
	
	public static class ActualResultStorage {
		private static Map<String, Object> actualResultMap = new HashMap<>();
		
		public static void setStorage() {
			actualResultMap = new HashMap<>();
		}
		
		public static <T> void put(String key, T value) {
			actualResultMap.put(key, value);
		}
		
		@SuppressWarnings("unchecked")
		public static <T> T getOrDefault(String key, T defaultValue) {
			return (T) actualResultMap.getOrDefault(key, defaultValue);
		}
	}
	
	static class Result<TestData, TInstance, TReturn> {
		public final AssertType assertType;
		public final TReturn expectedReturnValue;
		public final Class<? extends Throwable> expectedException;
		public final BiConsumer<TInstance, TReturn> customAction;
		public final List<SideEffect<TestData>> sideEffects;
		
		public Result(AssertType assertType) {
			this(assertType, (TReturn) null, null);
		}
	
		public Result(AssertType assertType, List<SideEffect<TestData>> sideEffects) {
			this(assertType, (TReturn) null, sideEffects);
		}
	
		public Result(AssertType assertType, TReturn expectedReturnValue) {
			this(assertType, expectedReturnValue, null);
		}
	
		public Result(AssertType assertType, Class<? extends Throwable> expectedException) {
			this(assertType, expectedException, null);
		}
	
		public Result(AssertType assertType, BiConsumer<TInstance, TReturn> customAction) {
			this(assertType, customAction, null);
		}
	
		public Result(AssertType assertType, TReturn expectedReturnValue, List<SideEffect<TestData>> sideEffects) {
			this(assertType, expectedReturnValue, null, null, sideEffects);
		}
	
		public Result(AssertType assertType, Class<? extends Throwable> expectedException, List<SideEffect<TestData>> sideEffects) {
			this(assertType, null, expectedException, null, sideEffects);
		}
	
		public Result(AssertType assertType, BiConsumer<TInstance, TReturn> customAction, List<SideEffect<TestData>> sideEffects) {
			this(assertType, null, null, customAction, sideEffects);
		}
	
		public Result(AssertType assertType, TReturn expectedReturnValue, Class<? extends Throwable> expectedException,
			BiConsumer<TInstance, TReturn> customAction, List<SideEffect<TestData>> sideEffects) {
			this.assertType = assertType;
			this.expectedReturnValue = expectedReturnValue;
			this.expectedException = expectedException;
			this.customAction = customAction;
			this.sideEffects = sideEffects;
		}
	}
	
	static class SideEffect<TestData> {
	    public final Object expectedValue;
	    public final Function<TestData, Object> actualValueAccessor;
	    
		public SideEffect(Object expectedValue, Function<TestData, Object> actualValueAccessor) {
			this.expectedValue = expectedValue;
			this.actualValueAccessor = actualValueAccessor;
		}
	}
	
	public enum AssertType {
	    EXCEPTION, EXPECTED_VALUE, CUSTOM_ASSERTION
	}
	
	static class VoidR {
	}
	
	private static <I> ExceptionFunction<I, VoidR> asFunc(ExceptionConsumer<I> action) {
		return i -> {
			action.accept(i);
			return null;
		};
	}
	
	@FunctionalInterface
	public interface ExceptionFunction<I, R> {
		R apply(I i) throws Exception;
	}
	
	@FunctionalInterface
	public interface ExceptionConsumer<I> {
		void accept(I i) throws Exception;
	}
	
	private <TestData, I, R> void assertion(TestData data, String methodName, I instance, Result<TestData, I, R> expectedResult, ExceptionFunction<I, R> toApply) {
		if (expectedResult == null) {
			ActualResultStorage.put(methodName, assertDoesNotThrow(() -> toApply.apply(instance)));
			return;
		}
		R actualResult = null;
		if (expectedResult.assertType.equals(AssertType.EXCEPTION)) {
			assertThrows(expectedResult.expectedException, () -> toApply.apply(instance));
		} else {
			actualResult = assertDoesNotThrow(() -> toApply.apply(instance));
			if (expectedResult.assertType.equals(AssertType.EXPECTED_VALUE) &&
					!(expectedResult.expectedReturnValue instanceof VoidR)) {
				assertEquals(expectedResult.expectedReturnValue, actualResult);
			} else if (expectedResult.assertType.equals(AssertType.CUSTOM_ASSERTION)) {
				expectedResult.customAction.accept(instance, actualResult);
			}
			if (expectedResult.sideEffects != null) {
				for (var sideEffect : expectedResult.sideEffects) {
					var sideEffectResult = sideEffect.actualValueAccessor.apply(data);
					assertEquals(sideEffect.expectedValue, sideEffectResult);
				}
			}
		}
		ActualResultStorage.put(methodName, actualResult);
	}
//endregion
}

/*
WARNING: Modification of this comment will make it impossible to merge user-defined changes

BEGIN_CODEGEN_DATA
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
END_CODEGEN_DATA
*/