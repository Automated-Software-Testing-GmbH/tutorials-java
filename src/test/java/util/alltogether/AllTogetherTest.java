/*
* DO NOT MODIFY THIS COMMENT
* Generated by devmate
* Test model: 979d8c8c-a248-4d25-b8ee-b4288393a5ab
*/
package util.alltogether;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.BiConsumer;
import java.util.function.Function;
import java.util.stream.Stream;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.joda.time.DateTime;

@SuppressWarnings("unused")
public class AllTogetherTest {
	
//region Custom Assertions
	private static void assertIsApproved(AllTogether instance, CreditReturnStatus result, CustomMatcherIsApprovedTestData data) {
	    assertEquals(data.resultCustomMatcher, result.approved);
	}
//endregion

//region Scenarios
	//A new scenario
	@ParameterizedTest(name = "{1} [{index}] {2}")
	@MethodSource({"ValidatePersonSource"})
	public void ValidatePersonTest(ValidatePersonTestData data, String TestName, String TestDescription) {
		ActualResultStorage.setStorage(); //saves the results of the called Methods
		
		assertion(data, data.S1M1.methodName, data.C1, data.S1M1.expectedResult, data.S1M1.call());
	}
		
	//A new scenario
	@ParameterizedTest(name = "{1} [{index}] {2}")
	@MethodSource({"CheckCreditSource"})
	public void CheckCreditTest(CheckCreditTestData data, String TestName, String TestDescription) {
		ActualResultStorage.setStorage(); //saves the results of the called Methods
		
		assertion(data, data.S2M1.methodName, data.C1, data.S2M1.expectedResult, data.S2M1.call());
	}
//endregion

//region Data

//=========================================================================================================================
//Please modify this section only in the Modeleditor not here in the code, because otherwise it will cause merge conflicts!
//=========================================================================================================================
	//A new scenario
	private static Stream<Arguments> ValidatePersonSource() {
		return Stream.of(
			Arguments.of(
				new ValidatePersonTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(2003, 1, 1, 0, 0), "John Brook"),
					/* S1M1 = */ new S1M1Parameters<>(
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.EXPECTED_VALUE
						)
					)
				),
				/* testCaseName = */ "p1",
				/* testCaseDescription = */ ""
			),
			Arguments.of(
				new ValidatePersonTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(1990, 1, 1, 0, 0), "John Brook"),
					/* S1M1 = */ new S1M1Parameters<>(
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.EXPECTED_VALUE
						)
					)
				),
				/* testCaseName = */ "p2",
				/* testCaseDescription = */ ""
			),
			Arguments.of(
				new ValidatePersonTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(2020, 1, 1, 0, 0), "John Brook"),
					/* S1M1 = */ new S1M1Parameters<>(
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.EXCEPTION,
							/* expectedException = */ Exception.class
						)
					)
				),
				/* testCaseName = */ "n1",
				/* testCaseDescription = */ "C1: Too Young"
			),
			Arguments.of(
				new ValidatePersonTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(2100, 1, 1, 0, 0), "John Brook"),
					/* S1M1 = */ new S1M1Parameters<>(
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.EXCEPTION,
							/* expectedException = */ Exception.class
						)
					)
				),
				/* testCaseName = */ "n2",
				/* testCaseDescription = */ "C1: DOB in future"
			),
			Arguments.of(
				new ValidatePersonTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(1990, 1, 1, 0, 0), "X"),
					/* S1M1 = */ new S1M1Parameters<>(
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.EXCEPTION,
							/* expectedException = */ Exception.class
						)
					)
				),
				/* testCaseName = */ "n3",
				/* testCaseDescription = */ "C1: Invalid name"
			)
		);
	}
		
	//A new scenario
	private static Stream<Arguments> CheckCreditSource() {
		return Stream.of(
			Arguments.of(
				new CheckCreditTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(2003, 1, 1, 0, 0), "John Brook"),
					/* S2M1 = */ new S2M1Parameters<>(
						/* Integer creditSought = */ 100,
						/* Integer duration = */ 12,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.CUSTOM_ASSERTION,
							/* customAction = */ (i, r) -> assertIsApproved(i, r, 
								new CustomMatcherIsApprovedTestData(
									/* resultCustomMatcher = */ true
								)
							)
						)
					)
				),
				/* testCaseName = */ "Valid 18-25",
				/* testCaseDescription = */ ""
			),
			Arguments.of(
				new CheckCreditTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(1990, 1, 1, 0, 0), "John Brook"),
					/* S2M1 = */ new S2M1Parameters<>(
						/* Integer creditSought = */ 100,
						/* Integer duration = */ 12,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.CUSTOM_ASSERTION,
							/* customAction = */ (i, r) -> assertIsApproved(i, r, 
								new CustomMatcherIsApprovedTestData(
									/* resultCustomMatcher = */ true
								)
							)
						)
					)
				),
				/* testCaseName = */ "Valid 26+",
				/* testCaseDescription = */ ""
			),
			Arguments.of(
				new CheckCreditTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(2003, 1, 1, 0, 0), "John Brook"),
					/* S2M1 = */ new S2M1Parameters<>(
						/* Integer creditSought = */ 1001,
						/* Integer duration = */ 12,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.CUSTOM_ASSERTION,
							/* customAction = */ (i, r) -> assertIsApproved(i, r, 
								new CustomMatcherIsApprovedTestData(
									/* resultCustomMatcher = */ false
								)
							)
						)
					)
				),
				/* testCaseName = */ "Invalid Credit 18-25",
				/* testCaseDescription = */ "M1:duration: Invalid 18 - 25"
			),
			Arguments.of(
				new CheckCreditTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(2003, 1, 1, 0, 0), "John Brook"),
					/* S2M1 = */ new S2M1Parameters<>(
						/* Integer creditSought = */ 100,
						/* Integer duration = */ 25,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.CUSTOM_ASSERTION,
							/* customAction = */ (i, r) -> assertIsApproved(i, r, 
								new CustomMatcherIsApprovedTestData(
									/* resultCustomMatcher = */ false
								)
							)
						)
					)
				),
				/* testCaseName = */ "Invalid Duration 18-25",
				/* testCaseDescription = */ "M1:duration: Invalid 25+"
			),
			Arguments.of(
				new CheckCreditTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(1990, 1, 1, 0, 0), "John Brook"),
					/* S2M1 = */ new S2M1Parameters<>(
						/* Integer creditSought = */ 10001,
						/* Integer duration = */ 12,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.CUSTOM_ASSERTION,
							/* customAction = */ (i, r) -> assertIsApproved(i, r, 
								new CustomMatcherIsApprovedTestData(
									/* resultCustomMatcher = */ false
								)
							)
						)
					)
				),
				/* testCaseName = */ "Invalid Credit 26+",
				/* testCaseDescription = */ "M1:creditSought: Credit 18 - 25"
			),
			Arguments.of(
				new CheckCreditTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(1990, 1, 1, 0, 0), "John Brook"),
					/* S2M1 = */ new S2M1Parameters<>(
						/* Integer creditSought = */ 100,
						/* Integer duration = */ 49,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.CUSTOM_ASSERTION,
							/* customAction = */ (i, r) -> assertIsApproved(i, r, 
								new CustomMatcherIsApprovedTestData(
									/* resultCustomMatcher = */ false
								)
							)
						)
					)
				),
				/* testCaseName = */ "Invalid Duration 26+",
				/* testCaseDescription = */ "M1:creditSought: Credit Over 25"
			)
		);
	}
//endregion

//region Types

//=========================================================================================================================
//Please modify this section only in the Modeleditor not here in the code, because otherwise it will cause merge conflicts!
//=========================================================================================================================
	static class ValidatePersonTestData {
	    public final AllTogether C1;
	    public final S1M1Parameters<ValidatePersonTestData> S1M1;
	    
	    public ValidatePersonTestData(AllTogether C1, S1M1Parameters<ValidatePersonTestData> S1M1) {
	    	this.C1 = C1;
	    	this.S1M1 = S1M1;
	    }
	}
		
	static class CheckCreditTestData {
	    public final AllTogether C1;
	    public final S2M1Parameters<CheckCreditTestData> S2M1;
	    
	    public CheckCreditTestData(AllTogether C1, S2M1Parameters<CheckCreditTestData> S2M1) {
	    	this.C1 = C1;
	    	this.S2M1 = S2M1;
	    }
	}

	static class S1M1Parameters<TestData> {
		public final String methodName = "S1M1";
	    public final Result<TestData, AllTogether, VoidR> expectedResult;
		public S1M1Parameters(Result<TestData, AllTogether, VoidR> expectedResult) {
	   		this.expectedResult = expectedResult;
	    }
	    
	    public ExceptionFunction<AllTogether, VoidR> call() {
	    	return asFunc(i ->
	    	 i.validatePerson());
		}
	}
		
	static class S2M1Parameters<TestData> {
		public final String methodName = "S2M1";
	    public final ObjectWrapper<Integer> creditSought;
	    public final ObjectWrapper<Integer> duration;
	    public final Result<TestData, AllTogether, CreditReturnStatus> expectedResult;
		public S2M1Parameters(Integer creditSought, Integer duration, String[] referencingMethodName, Result<TestData, AllTogether, CreditReturnStatus> expectedResult) {
			this.creditSought = new ObjectWrapper<>(creditSought, referencingMethodName[0]);
			this.duration = new ObjectWrapper<>(duration, referencingMethodName[1]);
	   		this.expectedResult = expectedResult;
	    }
	    
	    public ExceptionFunction<AllTogether, CreditReturnStatus> call() {
	    	return i ->
	    	 i.checkCredit(creditSought.get(), duration.get());
		}
	}

	static class CustomMatcherIsApprovedTestData {
	    public final Boolean resultCustomMatcher;
	    
	    public CustomMatcherIsApprovedTestData(Boolean result) {
	    	this.resultCustomMatcher = result;
	    }
	}
//endregion

//region Utility Classes

//=========================================================================================================================
//Please modify this section only in the Modeleditor not here in the code, because otherwise it will cause merge conflicts!
//=========================================================================================================================
	public static class ObjectWrapper<T> {
		public T object;
		public String referencingMethodName;
		
		public ObjectWrapper(T object, String referencingMethodName) {
			this.object = object;
			this.referencingMethodName = referencingMethodName;
		}
		
		public T get() {
			return ActualResultStorage.getOrDefault(referencingMethodName, object);
		}
	}
	
	public static class ActualResultStorage {
		private static Map<String, Object> actualResultMap = new HashMap<>();
		
		public static void setStorage() {
			actualResultMap = new HashMap<>();
		}
		
		public static <T> void put(String key, T value) {
			actualResultMap.put(key, value);
		}
		
		@SuppressWarnings("unchecked")
		public static <T> T getOrDefault(String key, T defaultValue) {
			return (T) actualResultMap.getOrDefault(key, defaultValue);
		}
	}
	
	static class Result<TestData, TInstance, TReturn> {
		public final AssertType assertType;
		public final TReturn expectedReturnValue;
		public final Class<? extends Throwable> expectedException;
		public final BiConsumer<TInstance, TReturn> customAction;
		public final List<SideEffect<TestData>> sideEffects;
		
		public Result(AssertType assertType) {
			this(assertType, (TReturn) null, null);
		}
	
		public Result(AssertType assertType, List<SideEffect<TestData>> sideEffects) {
			this(assertType, (TReturn) null, sideEffects);
		}
	
		public Result(AssertType assertType, TReturn expectedReturnValue) {
			this(assertType, expectedReturnValue, null);
		}
	
		public Result(AssertType assertType, Class<? extends Throwable> expectedException) {
			this(assertType, expectedException, null);
		}
	
		public Result(AssertType assertType, BiConsumer<TInstance, TReturn> customAction) {
			this(assertType, customAction, null);
		}
	
		public Result(AssertType assertType, TReturn expectedReturnValue, List<SideEffect<TestData>> sideEffects) {
			this(assertType, expectedReturnValue, null, null, sideEffects);
		}
	
		public Result(AssertType assertType, Class<? extends Throwable> expectedException, List<SideEffect<TestData>> sideEffects) {
			this(assertType, null, expectedException, null, sideEffects);
		}
	
		public Result(AssertType assertType, BiConsumer<TInstance, TReturn> customAction, List<SideEffect<TestData>> sideEffects) {
			this(assertType, null, null, customAction, sideEffects);
		}
	
		public Result(AssertType assertType, TReturn expectedReturnValue, Class<? extends Throwable> expectedException,
			BiConsumer<TInstance, TReturn> customAction, List<SideEffect<TestData>> sideEffects) {
			this.assertType = assertType;
			this.expectedReturnValue = expectedReturnValue;
			this.expectedException = expectedException;
			this.customAction = customAction;
			this.sideEffects = sideEffects;
		}
	}
	
	static class SideEffect<TestData> {
	    public final Object expectedValue;
	    public final Function<TestData, Object> actualValueAccessor;
	    
		public SideEffect(Object expectedValue, Function<TestData, Object> actualValueAccessor) {
			this.expectedValue = expectedValue;
			this.actualValueAccessor = actualValueAccessor;
		}
	}
	
	public enum AssertType {
	    EXCEPTION, EXPECTED_VALUE, CUSTOM_ASSERTION
	}
	
	static class VoidR {
	}
	
	private static <I> ExceptionFunction<I, VoidR> asFunc(ExceptionConsumer<I> action) {
		return i -> {
			action.accept(i);
			return null;
		};
	}
	
	@FunctionalInterface
	public interface ExceptionFunction<I, R> {
		R apply(I i) throws Exception;
	}
	
	@FunctionalInterface
	public interface ExceptionConsumer<I> {
		void accept(I i) throws Exception;
	}
	
	private <TestData, I, R> void assertion(TestData data, String methodName, I instance, Result<TestData, I, R> expectedResult, ExceptionFunction<I, R> toApply) {
		if (expectedResult == null) {
			ActualResultStorage.put(methodName, assertDoesNotThrow(() -> toApply.apply(instance)));
			return;
		}
		R actualResult = null;
		if (expectedResult.assertType.equals(AssertType.EXCEPTION)) {
			assertThrows(expectedResult.expectedException, () -> toApply.apply(instance));
		} else {
			actualResult = assertDoesNotThrow(() -> toApply.apply(instance));
			if (expectedResult.assertType.equals(AssertType.EXPECTED_VALUE) &&
					!(expectedResult.expectedReturnValue instanceof VoidR)) {
				assertEquals(expectedResult.expectedReturnValue, actualResult);
			} else if (expectedResult.assertType.equals(AssertType.CUSTOM_ASSERTION)) {
				expectedResult.customAction.accept(instance, actualResult);
			}
			if (expectedResult.sideEffects != null) {
				for (var sideEffect : expectedResult.sideEffects) {
					var sideEffectResult = sideEffect.actualValueAccessor.apply(data);
					assertEquals(sideEffect.expectedValue, sideEffectResult);
				}
			}
		}
		ActualResultStorage.put(methodName, actualResult);
	}
//endregion
}

/*
WARNING: Modification of this comment will make it impossible to merge user-defined changes

BEGIN_CODEGEN_DATA
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
END_CODEGEN_DATA
*/