/*
* DO NOT MODIFY THIS COMMENT
* Generated by devmate
* Test model: 979d8c8c-a248-4d25-b8ee-b4288393a5ab
*/
package util.alltogether;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.BiConsumer;
import java.util.function.Function;
import java.util.stream.Stream;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.joda.time.DateTime;

@SuppressWarnings("unused")
public class AllTogetherTest {
	
//region Custom Assertions
	private static void assertIsApproved(AllTogether instance, CreditReturnStatus result, CustomMatcherIsApprovedTestData data) {
	    // TODO implement Custom Assertion
	    // please implement your own custom assertion here
	    // you can find the parameters defined for your custom matcher under data.<name>CustomMatcher
	    // assertEqual(data.<name>CustomMatcher, result);
	    assertEquals(data.resultCustomMatcher, result.approved);
	}
//endregion

//region Scenarios
	//A new scenario
	@ParameterizedTest(name = "{1} [{index}] {2}")
	@MethodSource({"ValidatePersonSource"})
	public void ValidatePersonTest(ValidatePersonTestData data, String TestName, String TestDescription) {
		ActualResultStorage.setStorage(); //saves the results of the called Methods
		
		assertion(data, data.S1M1.methodName, data.C1, data.S1M1.expectedResult, data.S1M1.call());
	}
		
	//A new scenario
	@ParameterizedTest(name = "{1} [{index}] {2}")
	@MethodSource({"CheckCreditSource"})
	public void CheckCreditTest(CheckCreditTestData data, String TestName, String TestDescription) {
		ActualResultStorage.setStorage(); //saves the results of the called Methods
		
		assertion(data, data.S2M1.methodName, data.C1, data.S2M1.expectedResult, data.S2M1.call());
	}
//endregion

//region Data

//=========================================================================================================================
//Please modify this section only in the Modeleditor not here in the code, because otherwise it will cause merge conflicts!
//=========================================================================================================================
	//A new scenario
	private static Stream<Arguments> ValidatePersonSource() {
		return Stream.of(
			Arguments.of(
				new ValidatePersonTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(2003, 1, 1, 0, 0), "John Brook"),
					/* S1M1 = */ new S1M1Parameters<>(
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.EXPECTED_VALUE
						)
					)
				),
				/* testCaseName = */ "Valid 18-25",
				/* testCaseDescription = */ ""
			),
			Arguments.of(
				new ValidatePersonTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(1990, 1, 1, 0, 0), "John Brook"),
					/* S1M1 = */ new S1M1Parameters<>(
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.EXPECTED_VALUE
						)
					)
				),
				/* testCaseName = */ "Valid 26+",
				/* testCaseDescription = */ ""
			),
			Arguments.of(
				new ValidatePersonTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(2020, 1, 1, 0, 0), "John Brook"),
					/* S1M1 = */ new S1M1Parameters<>(
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.EXCEPTION,
							/* expectedException = */ Exception.class
						)
					)
				),
				/* testCaseName = */ "Too Young",
				/* testCaseDescription = */ "C1: Too Young"
			),
			Arguments.of(
				new ValidatePersonTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(2100, 1, 1, 0, 0), "John Brook"),
					/* S1M1 = */ new S1M1Parameters<>(
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.EXCEPTION,
							/* expectedException = */ Exception.class
						)
					)
				),
				/* testCaseName = */ "Future DOB",
				/* testCaseDescription = */ "C1: DOB in future"
			),
			Arguments.of(
				new ValidatePersonTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(1990, 1, 1, 0, 0), "X"),
					/* S1M1 = */ new S1M1Parameters<>(
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.EXCEPTION,
							/* expectedException = */ Exception.class
						)
					)
				),
				/* testCaseName = */ "Name too short",
				/* testCaseDescription = */ "C1: Invalid name"
			)
		);
	}
		
	//A new scenario
	private static Stream<Arguments> CheckCreditSource() {
		return Stream.of(
			Arguments.of(
				new CheckCreditTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(2003, 1, 1, 0, 0), "John Brook"),
					/* S2M1 = */ new S2M1Parameters<>(
						/* Integer creditSought = */ 100,
						/* Integer duration = */ 12,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.CUSTOM_ASSERTION,
							/* customAction = */ (i, r) -> assertIsApproved(i, r, 
								new CustomMatcherIsApprovedTestData(
									/* resultCustomMatcher = */ true
								)
							)
						)
					)
				),
				/* testCaseName = */ "Valid 18-25",
				/* testCaseDescription = */ ""
			),
			Arguments.of(
				new CheckCreditTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(1990, 1, 1, 0, 0), "John Brook"),
					/* S2M1 = */ new S2M1Parameters<>(
						/* Integer creditSought = */ 100,
						/* Integer duration = */ 12,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.CUSTOM_ASSERTION,
							/* customAction = */ (i, r) -> assertIsApproved(i, r, 
								new CustomMatcherIsApprovedTestData(
									/* resultCustomMatcher = */ true
								)
							)
						)
					)
				),
				/* testCaseName = */ "Valid 26+",
				/* testCaseDescription = */ ""
			),
			Arguments.of(
				new CheckCreditTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(2003, 1, 1, 0, 0), "John Brook"),
					/* S2M1 = */ new S2M1Parameters<>(
						/* Integer creditSought = */ 1001,
						/* Integer duration = */ 12,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.CUSTOM_ASSERTION,
							/* customAction = */ (i, r) -> assertIsApproved(i, r, 
								new CustomMatcherIsApprovedTestData(
									/* resultCustomMatcher = */ false
								)
							)
						)
					)
				),
				/* testCaseName = */ "Invalid Credit 18-25",
				/* testCaseDescription = */ "M1:duration: Invalid 18 - 25"
			),
			Arguments.of(
				new CheckCreditTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(2003, 1, 1, 0, 0), "John Brook"),
					/* S2M1 = */ new S2M1Parameters<>(
						/* Integer creditSought = */ 100,
						/* Integer duration = */ 25,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.CUSTOM_ASSERTION,
							/* customAction = */ (i, r) -> assertIsApproved(i, r, 
								new CustomMatcherIsApprovedTestData(
									/* resultCustomMatcher = */ false
								)
							)
						)
					)
				),
				/* testCaseName = */ "Invalid Duration 18-25",
				/* testCaseDescription = */ "M1:duration: Invalid 25+"
			),
			Arguments.of(
				new CheckCreditTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(1990, 1, 1, 0, 0), "John Brook"),
					/* S2M1 = */ new S2M1Parameters<>(
						/* Integer creditSought = */ 10001,
						/* Integer duration = */ 12,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.CUSTOM_ASSERTION,
							/* customAction = */ (i, r) -> assertIsApproved(i, r, 
								new CustomMatcherIsApprovedTestData(
									/* resultCustomMatcher = */ false
								)
							)
						)
					)
				),
				/* testCaseName = */ "Invalid Credit 26+",
				/* testCaseDescription = */ "M1:creditSought: Credit 18 - 25"
			),
			Arguments.of(
				new CheckCreditTestData(
					/* AllTogether C1 = */ new AllTogether(new DateTime(1990, 1, 1, 0, 0), "John Brook"),
					/* S2M1 = */ new S2M1Parameters<>(
						/* Integer creditSought = */ 100,
						/* Integer duration = */ 49,
						/* referencingMethodName = */ new String[2],
						/* expectedResult = */ new Result<>(
							/* assertType = */ AssertType.CUSTOM_ASSERTION,
							/* customAction = */ (i, r) -> assertIsApproved(i, r, 
								new CustomMatcherIsApprovedTestData(
									/* resultCustomMatcher = */ false
								)
							)
						)
					)
				),
				/* testCaseName = */ "Invalid Duration 26+",
				/* testCaseDescription = */ "M1:creditSought: Credit Over 25"
			)
		);
	}
//endregion

//region Types

//=========================================================================================================================
//Please modify this section only in the Modeleditor not here in the code, because otherwise it will cause merge conflicts!
//=========================================================================================================================
	static class ValidatePersonTestData {
	    public final AllTogether C1;
	    public final S1M1Parameters<ValidatePersonTestData> S1M1;
	    
	    public ValidatePersonTestData(AllTogether C1, S1M1Parameters<ValidatePersonTestData> S1M1) {
	    	this.C1 = C1;
	    	this.S1M1 = S1M1;
	    }
	}
		
	static class CheckCreditTestData {
	    public final AllTogether C1;
	    public final S2M1Parameters<CheckCreditTestData> S2M1;
	    
	    public CheckCreditTestData(AllTogether C1, S2M1Parameters<CheckCreditTestData> S2M1) {
	    	this.C1 = C1;
	    	this.S2M1 = S2M1;
	    }
	}

	static class S1M1Parameters<TestData> {
		public final String methodName = "S1M1";
	    public final Result<TestData, AllTogether, VoidR> expectedResult;
		public S1M1Parameters(Result<TestData, AllTogether, VoidR> expectedResult) {
	   		this.expectedResult = expectedResult;
	    }
	    
	    public ExceptionFunction<AllTogether, VoidR> call() {
	    	return asFunc(i ->
	    	 i.validatePerson());
		}
	}
		
	static class S2M1Parameters<TestData> {
		public final String methodName = "S2M1";
	    public final ObjectWrapper<Integer> creditSought;
	    public final ObjectWrapper<Integer> duration;
	    public final Result<TestData, AllTogether, CreditReturnStatus> expectedResult;
		public S2M1Parameters(Integer creditSought, Integer duration, String[] referencingMethodName, Result<TestData, AllTogether, CreditReturnStatus> expectedResult) {
			this.creditSought = new ObjectWrapper<>(creditSought, referencingMethodName[0]);
			this.duration = new ObjectWrapper<>(duration, referencingMethodName[1]);
	   		this.expectedResult = expectedResult;
	    }
	    
	    public ExceptionFunction<AllTogether, CreditReturnStatus> call() {
	    	return i ->
	    	 i.checkCredit(creditSought.get(), duration.get());
		}
	}

	static class CustomMatcherIsApprovedTestData {
	    public final Boolean resultCustomMatcher;
	    
	    public CustomMatcherIsApprovedTestData(Boolean result) {
	    	this.resultCustomMatcher = result;
	    }
	}
//endregion

//region Utility Classes

//=========================================================================================================================
//Please modify this section only in the Modeleditor not here in the code, because otherwise it will cause merge conflicts!
//=========================================================================================================================
	public static class ObjectWrapper<T> {
		public T object;
		public String referencingMethodName;
		
		public ObjectWrapper(T object, String referencingMethodName) {
			this.object = object;
			this.referencingMethodName = referencingMethodName;
		}
		
		public T get() {
			return ActualResultStorage.getOrDefault(referencingMethodName, object);
		}
	}
	
	public static class ActualResultStorage {
		private static Map<String, Object> actualResultMap = new HashMap<>();
		
		public static void setStorage() {
			actualResultMap = new HashMap<>();
		}
		
		public static <T> void put(String key, T value) {
			actualResultMap.put(key, value);
		}
		
		@SuppressWarnings("unchecked")
		public static <T> T getOrDefault(String key, T defaultValue) {
			return (T) actualResultMap.getOrDefault(key, defaultValue);
		}
	}
	
	static class Result<TestData, TInstance, TReturn> {
		public final AssertType assertType;
		public final TReturn expectedReturnValue;
		public final Class<? extends Throwable> expectedException;
		public final BiConsumer<TInstance, TReturn> customAction;
		public final List<SideEffect<TestData>> sideEffects;
		
		public Result(AssertType assertType) {
			this(assertType, (TReturn) null, null);
		}
	
		public Result(AssertType assertType, List<SideEffect<TestData>> sideEffects) {
			this(assertType, (TReturn) null, sideEffects);
		}
	
		public Result(AssertType assertType, TReturn expectedReturnValue) {
			this(assertType, expectedReturnValue, null);
		}
	
		public Result(AssertType assertType, Class<? extends Throwable> expectedException) {
			this(assertType, expectedException, null);
		}
	
		public Result(AssertType assertType, BiConsumer<TInstance, TReturn> customAction) {
			this(assertType, customAction, null);
		}
	
		public Result(AssertType assertType, TReturn expectedReturnValue, List<SideEffect<TestData>> sideEffects) {
			this(assertType, expectedReturnValue, null, null, sideEffects);
		}
	
		public Result(AssertType assertType, Class<? extends Throwable> expectedException, List<SideEffect<TestData>> sideEffects) {
			this(assertType, null, expectedException, null, sideEffects);
		}
	
		public Result(AssertType assertType, BiConsumer<TInstance, TReturn> customAction, List<SideEffect<TestData>> sideEffects) {
			this(assertType, null, null, customAction, sideEffects);
		}
	
		public Result(AssertType assertType, TReturn expectedReturnValue, Class<? extends Throwable> expectedException,
			BiConsumer<TInstance, TReturn> customAction, List<SideEffect<TestData>> sideEffects) {
			this.assertType = assertType;
			this.expectedReturnValue = expectedReturnValue;
			this.expectedException = expectedException;
			this.customAction = customAction;
			this.sideEffects = sideEffects;
		}
	}
	
	static class SideEffect<TestData> {
	    public final Object expectedValue;
	    public final Function<TestData, Object> actualValueAccessor;
	    
		public SideEffect(Object expectedValue, Function<TestData, Object> actualValueAccessor) {
			this.expectedValue = expectedValue;
			this.actualValueAccessor = actualValueAccessor;
		}
	}
	
	public enum AssertType {
	    EXCEPTION, EXPECTED_VALUE, CUSTOM_ASSERTION
	}
	
	static class VoidR {
	}
	
	private static <I> ExceptionFunction<I, VoidR> asFunc(ExceptionConsumer<I> action) {
		return i -> {
			action.accept(i);
			return null;
		};
	}
	
	@FunctionalInterface
	public interface ExceptionFunction<I, R> {
		R apply(I i) throws Exception;
	}
	
	@FunctionalInterface
	public interface ExceptionConsumer<I> {
		void accept(I i) throws Exception;
	}
	
	private <TestData, I, R> void assertion(TestData data, String methodName, I instance, Result<TestData, I, R> expectedResult, ExceptionFunction<I, R> toApply) {
		if (expectedResult == null) {
			ActualResultStorage.put(methodName, assertDoesNotThrow(() -> toApply.apply(instance)));
			return;
		}
		R actualResult = null;
		if (expectedResult.assertType.equals(AssertType.EXCEPTION)) {
			assertThrows(expectedResult.expectedException, () -> toApply.apply(instance));
		} else {
			actualResult = assertDoesNotThrow(() -> toApply.apply(instance));
			if (expectedResult.assertType.equals(AssertType.EXPECTED_VALUE) &&
					!(expectedResult.expectedReturnValue instanceof VoidR)) {
				assertEquals(expectedResult.expectedReturnValue, actualResult);
			} else if (expectedResult.assertType.equals(AssertType.CUSTOM_ASSERTION)) {
				expectedResult.customAction.accept(instance, actualResult);
			}
			if (expectedResult.sideEffects != null) {
				for (var sideEffect : expectedResult.sideEffects) {
					var sideEffectResult = sideEffect.actualValueAccessor.apply(data);
					assertEquals(sideEffect.expectedValue, sideEffectResult);
				}
			}
		}
		ActualResultStorage.put(methodName, actualResult);
	}
//endregion
}

/*
WARNING: Modification of this comment will make it impossible to merge user-defined changes

BEGIN_CODEGEN_DATA
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
END_CODEGEN_DATA
*/